name: CI/CD Pipeline with Regression Detection

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  quality-checks:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        check: [lint, type-check, test]
      fail-fast: false
    name: ${{ matrix.check }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: üîí Secret Scanning
        run: |
          echo "üîç Scanning for accidentally committed secrets..."

          # Define secret patterns to check (pk_test_ excluded as they're safe publishable keys)
          SECRET_PATTERNS='(sk_live_[a-zA-Z0-9]{20,}|sk_test_[a-zA-Z0-9]{20,}|pk_live_[a-zA-Z0-9]{20,}|whsec_[a-zA-Z0-9]{20,})'

          # Check for secrets in all tracked files (excluding .env.example and similar)
          FOUND_SECRETS=$(git ls-files | \
            grep -v -E "(\.env\.example|\.env\.sample|example\.|sample\.)" | \
            xargs grep -E "$SECRET_PATTERNS" 2>/dev/null | \
            grep -v -E "(YOUR_|PLACEHOLDER|EXAMPLE|<.*>|docs/SECURITY\.md)" || true)

          if [ -n "$FOUND_SECRETS" ]; then
            echo "‚ùå SECURITY ALERT: Potential secrets found in repository!"
            echo ""
            echo "Found in files:"
            echo "$FOUND_SECRETS" | head -10
            echo ""
            echo "Please remove secrets and use placeholders instead."
            echo "See docs/SECURITY.md for proper secret handling."
            exit 1
          fi

          echo "‚úÖ No secrets detected in repository"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.1.0

      - name: Get pnpm store directory
        id: pnpm-cache
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: üîí Security Audit
        run: |
          echo "üîç Checking for security vulnerabilities in dependencies..."

          # Production dependencies - STRICT (fail on moderate or higher)
          echo ""
          echo "üì¶ Auditing production dependencies..."
          pnpm audit --prod --audit-level moderate || {
            EXIT_CODE=$?
            echo "‚ùå CRITICAL: Production vulnerabilities found!"
            echo "These vulnerabilities affect your users and must be fixed immediately."
            echo "Run 'pnpm audit --prod' locally to see details"
            exit $EXIT_CODE
          }
          echo "‚úÖ Production dependencies secure (no moderate+ vulnerabilities)"

          # Development dependencies - LENIENT (fail only on high or critical)
          echo ""
          echo "üõ†Ô∏è Auditing development dependencies..."
          pnpm audit --dev --audit-level high || {
            EXIT_CODE=$?
            echo "‚ùå High/Critical vulnerabilities found in dev dependencies!"
            echo "These should be addressed but don't affect production users."
            echo "Run 'pnpm audit --dev' locally to see details"
            exit $EXIT_CODE
          }

          # Check for moderate dev vulnerabilities (warning only, non-blocking)
          echo ""
          echo "üìã Checking for moderate dev dependency vulnerabilities..."
          if ! pnpm audit --dev --audit-level moderate 2>/dev/null; then
            echo "‚ö†Ô∏è Moderate vulnerabilities found in dev dependencies (non-blocking)"
            echo "These don't block CI but should be reviewed in the next maintenance cycle."
            echo "Run 'pnpm audit --dev' locally for details"
          else
            echo "‚úÖ Dev dependencies secure (no moderate+ vulnerabilities)"
          fi

          echo ""
          echo "‚úÖ Security audit complete"

      - name: Verify Convex files
        uses: ./.github/actions/verify-convex

      - name: Cache Convex generated files
        id: convex-cache
        uses: actions/cache@v4
        with:
          path: convex/_generated
          key: ${{ runner.os }}-convex-${{ hashFiles('convex/schema.ts', 'convex/**/*.ts') }}
          restore-keys: |
            ${{ runner.os }}-convex-

      - name: Generate Convex files
        # Skip if files exist (either from git or cache restore-key fallback)
        # Only run codegen when files are completely missing
        if: steps.convex-cache.outputs.cache-hit != 'true' && hashFiles('convex/_generated/api.js') == ''
        run: npx convex codegen
        env:
          CONVEX_DEPLOYMENT: fleet-goldfish-183

      - name: Run linting
        if: matrix.check == 'lint'
        run: pnpm lint

      - name: Run type checking
        if: matrix.check == 'type-check'
        run: pnpm type-check

      - name: Run tests with coverage
        if: matrix.check == 'test'
        run: pnpm test:coverage

      - name: Generate coverage summary
        if: matrix.check == 'test' && always()
        run: |
          echo "## üìä Test Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f coverage/coverage-summary.json ]; then
            echo '```json' >> $GITHUB_STEP_SUMMARY
            cat coverage/coverage-summary.json | jq '.total' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Coverage report generated successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ö†Ô∏è Coverage report not found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Coverage Report
        if: matrix.check == 'test' && github.event_name == 'pull_request'
        uses: davelosert/vitest-coverage-report-action@v2
        with:
          vite-config-path: vitest.config.ts
          github-token: ${{ secrets.GITHUB_TOKEN }}
          file-coverage-mode: changes

      - name: Update Coverage Badges
        if: matrix.check == 'test' && github.ref == 'refs/heads/master'
        env:
          GH_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          # Generate badge JSON files with color logic
          for metric in lines branches functions statements; do
            VALUE=$(jq ".total.${metric}.pct" coverage/coverage-summary.json)

            # Color thresholds: brightgreen (‚â•80%), yellow (‚â•70%), red (<70%)
            if (( $(echo "$VALUE >= 80" | bc -l) )); then
              COLOR="brightgreen"
            elif (( $(echo "$VALUE >= 70" | bc -l) )); then
              COLOR="yellow"
            else
              COLOR="red"
            fi

            # Capitalize metric for label
            LABEL=$(echo "$metric" | sed 's/.*/\u&/')
            echo "{\"schemaVersion\":1,\"label\":\"$LABEL\",\"message\":\"${VALUE}%\",\"color\":\"$COLOR\"}" > /tmp/coverage-${metric}.json
          done

          # Update all badge files atomically via API (avoids 409 conflicts)
          jq -n \
            --arg lines "$(cat /tmp/coverage-lines.json)" \
            --arg branches "$(cat /tmp/coverage-branches.json)" \
            --arg functions "$(cat /tmp/coverage-functions.json)" \
            --arg statements "$(cat /tmp/coverage-statements.json)" \
            '{files: {
              "coverage-lines.json": {content: $lines},
              "coverage-branches.json": {content: $branches},
              "coverage-functions.json": {content: $functions},
              "coverage-statements.json": {content: $statements}
            }}' | gh api --method PATCH /gists/${{ vars.COVERAGE_GIST_ID }} --input -

  validation:
    runs-on: ubuntu-latest
    name: validation-checks

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.1.0

      - name: Get pnpm store directory
        id: pnpm-cache
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run puzzle validation
        run: pnpm validate-puzzles

      - name: Test module system compatibility
        run: pnpm test-module-system

  docs:
    runs-on: ubuntu-latest
    name: docs-link-check

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check documentation links
        uses: lycheeverse/lychee-action@v2
        with:
          args: --offline --no-progress '**/*.md'
          fail: false

  build:
    runs-on: ubuntu-latest
    needs: [quality-checks, validation]

    # ENVIRONMENT VARIABLES DOCUMENTATION
    # ====================================
    # This job requires the following environment variables:
    #
    # Required for Convex (backend):
    # - CONVEX_DEPLOYMENT: The Convex deployment identifier (used for codegen)
    # - NEXT_PUBLIC_CONVEX_URL: The public Convex URL (embedded in client bundle)
    #
    # Required for Clerk (authentication):
    # - NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: Public key for Clerk auth (embedded in client bundle)
    #
    # Optional:
    # - None currently
    #
    # IMPORTANT: Only NEXT_PUBLIC_* prefixed variables are embedded in the client bundle.
    # Server-side variables (without NEXT_PUBLIC_ prefix) remain secure on the server.
    #
    # These variables must be provided at:
    # 1. Build time - for Next.js to embed them in the client bundle
    # 2. Runtime - for the production server to start without errors

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.1.0

      - name: Get pnpm store directory
        id: pnpm-cache
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Cache Next.js build
        uses: actions/cache@v4
        with:
          path: |
            .next/cache
            .next/.next-build-cache
            .next/server
            node_modules/.cache
          key: ${{ runner.os }}-nextjs-${{ hashFiles('pnpm-lock.yaml') }}-${{ hashFiles('src/**/*.[jt]sx?') }}
          restore-keys: |
            ${{ runner.os }}-nextjs-${{ hashFiles('pnpm-lock.yaml') }}-
            ${{ runner.os }}-nextjs-

      - name: Verify Convex files
        uses: ./.github/actions/verify-convex

      - name: Cache Convex generated files
        id: convex-cache
        uses: actions/cache@v4
        with:
          path: convex/_generated
          key: ${{ runner.os }}-convex-${{ hashFiles('convex/schema.ts', 'convex/**/*.ts') }}
          restore-keys: |
            ${{ runner.os }}-convex-

      - name: Generate Convex files
        if: steps.convex-cache.outputs.cache-hit != 'true'
        run: npx convex codegen
        env:
          # Server-side only: Used to identify which Convex deployment to generate types for
          CONVEX_DEPLOYMENT: fleet-goldfish-183

      - name: Build application
        run: pnpm build
        env:
          # Client-side: Embedded in the JavaScript bundle for browser access
          NEXT_PUBLIC_CONVEX_URL: https://fleet-goldfish-183.convex.cloud
          # Client-side: Public key for Clerk authentication (safe to expose)
          # This is a TEST publishable key - NOT a secret. Publishable keys are meant to be public.
          # pk_test_ keys are specifically for test environments and safe in CI configurations
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: pk_test_aGVhbHRoeS1kb2UtMjMuY2xlcmsuYWNjb3VudHMuZGV2JA

      - name: Verify environment variable handling
        run: |
          echo "üîç Verifying environment variable handling..."

          # Check that NEXT_PUBLIC_ variables are included in the build output
          if grep -q "NEXT_PUBLIC_CONVEX_URL" .next/static/chunks/*.js 2>/dev/null || \
             grep -q "fleet-goldfish-183" .next/static/chunks/*.js 2>/dev/null; then
            echo "‚úÖ NEXT_PUBLIC_CONVEX_URL properly embedded in client bundle"
          else
            echo "‚ö†Ô∏è Warning: NEXT_PUBLIC_CONVEX_URL might not be properly embedded"
          fi

          # Ensure no actual sensitive values are exposed (not just variable names)
          # Check for actual Clerk secret keys (start with sk_test_ or sk_live_ followed by 48+ chars)
          if grep -E "sk_(test|live)_[A-Za-z0-9]{40,}" .next/static/chunks/*.js 2>/dev/null; then
            echo "‚ùå ERROR: Actual Clerk secret key found in client bundle!"
            echo "Secret keys must never be exposed in client-side code"
            exit 1
          fi

          # Check for actual Convex deployment keys (format: prod:project-name|base64key)
          if grep -E "(dev|prod):[a-z-]+\|[A-Za-z0-9+/=]{20,}" .next/static/chunks/*.js 2>/dev/null; then
            echo "‚ùå ERROR: Convex deployment key found in client bundle!"
            echo "Deployment keys must never be exposed in client-side code"
            exit 1
          fi

          echo "‚úÖ No sensitive secrets exposed in client bundle"

          echo "‚úÖ Environment variable verification passed"

      - name: Check bundle size
        run: |
          echo "üìä Checking bundle sizes against configured limits..."
          pnpm size
          if [ $? -ne 0 ]; then
            echo "‚ùå Bundle size limits exceeded! Please optimize your code."
            echo "üí° Tips:"
            echo "   - Check for unnecessary dependencies"
            echo "   - Use dynamic imports for large components"
            echo "   - Analyze bundle with 'pnpm bundle-analysis'"
            exit 1
          fi
          echo "‚úÖ Bundle sizes within limits"

      - name: Remove files with colons (incompatible with artifact upload)
        run: find .next -name '*:*' -delete

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: .next/
          include-hidden-files: true

  e2e:
    runs-on: ubuntu-latest
    needs: build
    name: e2e

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 9.1.0

      - name: Get pnpm store directory
        id: pnpm-cache
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-output
          path: .next/

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps chromium

      - name: Run e2e tests
        run: pnpm test:e2e
        env:
          NEXT_PUBLIC_CONVEX_URL: https://handsome-raccoon-955.convex.cloud
          NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY: pk_test_aGVhbHRoeS1kb2UtMjMuY2xlcmsuYWNjb3VudHMuZGV2JA
          CLERK_SECRET_KEY: ${{ secrets.CLERK_SECRET_KEY }}

      - name: Upload Playwright report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 7

  # Verify production secrets are configured before merge
  # Prevents post-merge deploy failures due to missing secrets
  verify-production-secrets:
    name: Verify Production Secrets
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && (github.base_ref == 'master' || github.base_ref == 'main')

    steps:
      - name: Check production secrets are configured
        run: |
          echo "üîê Verifying production secrets for post-merge deploy..."
          errors=0

          check_secret() {
            if [ -z "$1" ]; then
              echo "::error::Production secret not configured: $2"
              errors=$((errors + 1))
            else
              echo "‚úì $2"
            fi
          }

          echo "=== Required for Deploy ==="
          check_secret "$CLERK_KEY" "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY"
          check_secret "$CONVEX_URL" "NEXT_PUBLIC_CONVEX_URL"
          check_secret "$CONVEX_KEY" "CONVEX_DEPLOY_KEY"

          if [ $errors -gt 0 ]; then
            echo ""
            echo "::error::$errors production secret(s) missing!"
            echo "Merging this PR will trigger a failing deploy."
            echo ""
            echo "Add missing secrets at:"
            echo "GitHub repo ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions"
            exit 1
          fi

          echo ""
          echo "‚úÖ All required production secrets verified"
        env:
          CLERK_KEY: ${{ secrets.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY }}
          CONVEX_URL: ${{ secrets.NEXT_PUBLIC_CONVEX_URL }}
          CONVEX_KEY: ${{ secrets.CONVEX_DEPLOY_KEY }}
