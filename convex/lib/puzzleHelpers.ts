import { DatabaseWriter, QueryCtx } from "../_generated/server";
import { Doc, Id } from "../_generated/dataModel";

/**
 * Puzzle Helpers - Database Operations for Puzzles
 *
 * Module: Shared database helpers for puzzle operations
 * Location: convex/lib/ (not code-generated by Convex)
 *
 * Exports:
 * - updatePuzzleStats: Update puzzle statistics after completion
 * - selectYearForPuzzle: Select a random year with sufficient events for puzzle generation
 * - selectDiverseEvents: Select 6 events maximizing topic diversity
 */

// Maximum events from any single category (prevents Augustus-style puzzles)
const MAX_EVENTS_PER_CATEGORY = 2;

// Minimum categories required for a diverse puzzle
const MIN_CATEGORIES_FOR_DIVERSITY = 3;

/**
 * Fisher-Yates shuffle algorithm for true randomness
 *
 * The common `.sort(() => Math.random() - 0.5)` pattern has poor distribution
 * properties and is not truly random. Fisher-Yates provides uniform distribution.
 *
 * Algorithm:
 * - Start from the end of the array
 * - For each position, swap with a random position from 0 to current position
 * - This ensures each permutation is equally likely
 *
 * @param array - Array to shuffle (will be copied, original unchanged)
 * @returns New shuffled array
 */
function fisherYatesShuffle<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Update puzzle statistics after completion
 *
 * Calculates and updates aggregate statistics for a puzzle based on all completed plays.
 * Called by submitGuess mutation when a user completes a puzzle.
 *
 * Statistics calculated:
 * - playCount: Total number of completed plays
 * - avgGuesses: Average number of guesses across all completions (rounded to 1 decimal)
 *
 * Performance: O(n) where n = number of completed plays for the puzzle
 *
 * @param ctx - Database writer context
 * @param puzzleId - Puzzle ID to update statistics for
 */
export async function updatePuzzleStats(
  ctx: { db: DatabaseWriter },
  puzzleId: Id<"puzzles">,
): Promise<void> {
  // Get all completed plays for this puzzle
  const completedPlays = await ctx.db
    .query("plays")
    .withIndex("by_puzzle", (q) => q.eq("puzzleId", puzzleId))
    .filter((q) => q.neq(q.field("completedAt"), null))
    .collect();

  const playCount = completedPlays.length;
  if (playCount === 0) return;

  // Calculate average guesses
  const totalGuesses = completedPlays.reduce((sum: number, play) => {
    if (play.ranges && play.ranges.length > 0) {
      return sum + play.ranges.length;
    }
    return sum + (play.guesses?.length ?? 0);
  }, 0);
  const avgGuesses = totalGuesses / playCount;

  // Update puzzle with calculated statistics
  await ctx.db.patch(puzzleId, {
    playCount,
    avgGuesses: Math.round(avgGuesses * 10) / 10, // Round to 1 decimal
    updatedAt: Date.now(),
  });
}

/**
 * Selects a random year with 6+ unused events for puzzle generation.
 *
 * Algorithm:
 * 1. Query all unused events (puzzleId = undefined)
 * 2. Group by year and count available events
 * 3. Filter to years with 6+ events (minimum for puzzle)
 * 4. Randomly select one eligible year
 * 5. Return selected year with its events
 *
 * Module Value: Hides complex year selection algorithm behind simple interface.
 * Deep Module: 40 lines of implementation complexity â†’ 1 function call
 *
 * @param ctx - Database query context
 * @returns Selected year, its events, and availability count
 * @throws Error if no years have 6+ unused events
 */
export async function selectYearForPuzzle(ctx: QueryCtx): Promise<{
  year: number;
  events: Doc<"events">[];
  availableEvents: number;
}> {
  // Get all unused events from Classic mode pool
  const unusedEvents = await ctx.db
    .query("events")
    .filter((q) => q.eq(q.field("classicPuzzleId"), undefined))
    .collect();

  // Group by year and count available events per year
  const yearCounts = new Map<number, number>();
  for (const event of unusedEvents) {
    const count = yearCounts.get(event.year) || 0;
    yearCounts.set(event.year, count + 1);
  }

  // Filter to years with sufficient events (6 minimum for puzzle)
  const availableYears = Array.from(yearCounts.entries())
    .filter(([, count]) => count >= 6)
    .map(([year, count]) => ({ year, availableEvents: count }))
    .sort((a, b) => a.year - b.year);

  if (availableYears.length === 0) {
    throw new Error("No years available with enough unused events");
  }

  // Randomly select one eligible year
  const randomYear = availableYears[Math.floor(Math.random() * availableYears.length)];

  // Get all unused events for the selected year (Classic mode)
  const yearEvents = await ctx.db
    .query("events")
    .withIndex("by_year", (q) => q.eq("year", randomYear.year))
    .filter((q) => q.eq(q.field("classicPuzzleId"), undefined))
    .collect();

  // Use diversity-aware selection to maximize topic variety
  const selectedEvents = selectDiverseEvents(yearEvents, 6);

  if (selectedEvents.length < 6) {
    throw new Error(`Not enough events for year ${randomYear.year}`);
  }

  return {
    year: randomYear.year,
    events: selectedEvents,
    availableEvents: randomYear.availableEvents,
  };
}

/**
 * Selects events to maximize topic diversity.
 *
 * Algorithm:
 * 1. Group events by their primary category
 * 2. Select at most MAX_EVENTS_PER_CATEGORY from each category
 * 3. Prioritize events with metadata, fall back to random for uncategorized
 * 4. Order by difficulty (hardest first) for optimal hint progression
 *
 * This prevents "Augustus puzzles" where all hints test the same knowledge.
 *
 * @param events - Pool of available events
 * @param count - Number of events to select (typically 6)
 * @returns Selected events ordered by difficulty (hardest first)
 */
export function selectDiverseEvents<T extends Doc<"events">>(events: T[], count: number): T[] {
  if (events.length <= count) {
    // Not enough events, return all sorted by difficulty
    return sortByDifficulty(events);
  }

  // Separate events with and without category metadata
  const categorized: T[] = [];
  const uncategorized: T[] = [];

  for (const event of events) {
    const categories = event.metadata?.category;
    if (categories && categories.length > 0) {
      categorized.push(event);
    } else {
      uncategorized.push(event);
    }
  }

  // Group categorized events by their primary category
  const byCategory = new Map<string, T[]>();
  for (const event of categorized) {
    const primaryCategory = event.metadata?.category?.[0] ?? "unknown";
    const existing = byCategory.get(primaryCategory) ?? [];
    existing.push(event);
    byCategory.set(primaryCategory, existing);
  }

  // Select events using round-robin across categories
  const selected: T[] = [];
  const categoryQueues = new Map<string, T[]>();

  // Shuffle events within each category for randomness
  for (const [category, categoryEvents] of byCategory) {
    categoryQueues.set(category, fisherYatesShuffle(categoryEvents));
  }

  // Round-robin selection: take one from each category until we have enough
  // or hit MAX_EVENTS_PER_CATEGORY for each
  const categoryUsage = new Map<string, number>();
  let iteration = 0;
  const maxIterations = count * 10; // Safety limit

  while (selected.length < count && iteration < maxIterations) {
    iteration++;
    let madeProgress = false;

    for (const [category, queue] of categoryQueues) {
      if (selected.length >= count) break;

      const usage = categoryUsage.get(category) ?? 0;
      if (usage >= MAX_EVENTS_PER_CATEGORY) continue;

      const event = queue.shift();
      if (event) {
        selected.push(event);
        categoryUsage.set(category, usage + 1);
        madeProgress = true;
      }
    }

    // If no progress made from categorized events, break to use uncategorized
    if (!madeProgress) break;
  }

  // If still need more events, fill from uncategorized pool (randomized)
  if (selected.length < count && uncategorized.length > 0) {
    const shuffledUncategorized = fisherYatesShuffle(uncategorized);
    const needed = count - selected.length;
    selected.push(...shuffledUncategorized.slice(0, needed));
  }

  // Final fallback: if still not enough, take any remaining categorized events
  if (selected.length < count) {
    const selectedIds = new Set(selected.map((e) => e._id));
    const remaining = events.filter((e) => !selectedIds.has(e._id));
    const shuffledRemaining = fisherYatesShuffle(remaining);
    selected.push(...shuffledRemaining.slice(0, count - selected.length));
  }

  // Sort by difficulty: hardest first for optimal hint progression
  return sortByDifficulty(selected.slice(0, count));
}

/**
 * Sorts events by difficulty (hardest first).
 * Events without difficulty metadata are placed in the middle (assumed difficulty 3).
 */
function sortByDifficulty<T extends Doc<"events">>(events: T[]): T[] {
  return [...events].sort((a, b) => {
    const diffA = a.metadata?.difficulty ?? 3;
    const diffB = b.metadata?.difficulty ?? 3;
    return diffB - diffA; // Higher difficulty first (harder hints first)
  });
}

/**
 * Computes diversity score for a set of events.
 * Used to evaluate puzzle quality before creation.
 *
 * @param events - Events to evaluate
 * @returns Diversity score 0-1 (1 = perfectly diverse)
 */
export function computeDiversityScore(events: Doc<"events">[]): number {
  if (events.length === 0) return 0;

  // Count unique categories
  const categories = new Set<string>();
  let categorizedCount = 0;

  for (const event of events) {
    const eventCategories = event.metadata?.category ?? [];
    for (const cat of eventCategories) {
      categories.add(cat);
    }
    if (eventCategories.length > 0) {
      categorizedCount++;
    }
  }

  // Score based on:
  // 1. Number of unique categories (target: at least 3 for 6 events)
  // 2. Metadata coverage (how many events have categories)
  const categoryScore = Math.min(1, categories.size / MIN_CATEGORIES_FOR_DIVERSITY);
  const coverageScore = categorizedCount / events.length;

  // Weight category diversity higher
  return 0.7 * categoryScore + 0.3 * coverageScore;
}
